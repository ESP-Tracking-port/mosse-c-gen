#include "MosseApi.hpp"
#include "MosseTables/MosseTables.hpp"
#include <array>
#include <limits>
#include <cstdlib>
#include <type_traits>

namespace @MOSSENAMESPACE@ {

template <class T, class ...Ts>
static constexpr auto makeArray(T &&a, Ts &&...as) -> std::array<typename std::decay<T>::type, 1 + sizeof...(Ts)>
{
	using Type = typename std::decay<T>::type;
	// static_assert(std::is_same<typename std::decay<const float(*)[80]>::type, float **>::value, "");
	return std::array<Type, 1 + sizeof...(Ts)>{{Type{a}, Type{as}...}};
}

@MAPS@

void getClosestWindow(unsigned &aRows, unsigned &aCols)
{
	auto prevDiff = std::numeric_limits<unsigned>::max();
	const auto area = aRows * aCols;
	int minCounter = 0;
	int counter = 0;

	for (const auto window : kWindowSizes) {
		auto diff = abs(window[0] * window[1] - area);

		if (diff < prevDiff) {
			prevDiff = diff;
			minCounter = counter;
		}

		++counter;
	}

	aRows = kWindowSizes[counter][0];
	aCols = kWindowSizes[counter][1];
}

int checkWindowExists(unsigned aRows, unsigned aCols)
{
	int counter = 0;

	for (const auto size : kWindowSizes) {
		if (aRows == size[0] && aCols == size[1]) {
			return counter;
		}

		counter += 1;
	}

	return -1;
}

const float *getHann(unsigned aRows, unsigned aCols)
{
	int id = checkWindowExists(aRows, aCols);

	if (id < 0) {
		return nullptr;
	}

	return kHannMap[id];
}

std::pair<const float *, const float *> getGaussKernelFft(unsigned aRows, unsigned aCols)
{
	int id = checkWindowExists(aRows, aCols);

	if (id < 0) {
		return {nullptr, nullptr};
	}

	return kGaussKernelFftMapImReal[id];
}

}  // namespace @MOSSENAMESPACE@
